---
description: 
globs: 
alwaysApply: true
---
project:
  name: UzoFitness
  language: Swift
  architecture: MVVM
  target: iOS 18.0+
  device: iphone 15+
  xcode_version: 16.0+

# Folder structure convention
guidelines:
  - id: folder-structure
    description: |
      Use a clear MVVM-aligned folder structure:
        ‚îú‚îÄ‚îÄ Models/          # Data entities and SwiftData models
        ‚îú‚îÄ‚îÄ ViewModels/      # ObservableObjects for view logic
        ‚îú‚îÄ‚îÄ Views/           # SwiftUI Views
        ‚îÇ   ‚îú‚îÄ‚îÄ Components/  # Reusable UI components
        ‚îÇ   ‚îî‚îÄ‚îÄ Screens/     # Main app screens
        ‚îú‚îÄ‚îÄ Services/        # Business-logic layers (e.g., HealthKit, photo)
        ‚îú‚îÄ‚îÄ Resources/       # Assets, Info.plist, localization files
        ‚îú‚îÄ‚îÄ Utilities/       # Extensions, helpers, formatters
        ‚îî‚îÄ‚îÄ Tests/           # Unit and UI tests
    appliesTo:
      - "*"

  - id: naming-conventions
    description: |
      ‚Ä¢ Types (struct, class, enum) use UpperCamelCase.
      ‚Ä¢ Properties & methods use lowerCamelCase.
      ‚Ä¢ Constants use UPPER_SNAKE_CASE for static let values.
      ‚Ä¢ Protocol names end with "Protocol" (e.g., HealthStoreProtocol).
      ‚Ä¢ View files end with "View" (e.g., WorkoutListView).
      ‚Ä¢ ViewModel files end with "ViewModel" (e.g., WorkoutListViewModel).
      ‚Ä¢ Service files end with "Service" or "Manager" (e.g., HealthKitManager).
    appliesTo:
      - "*.swift"

  - id: code-style
    description: |
      ‚Ä¢ Follow SwiftLint default rules (indent: 4 spaces, max line length: 100).
      ‚Ä¢ Prefer `guard` over deep nesting.
      ‚Ä¢ Mark immutable values with `let`.
      ‚Ä¢ Use trailing closures for single-parameter closures.
      ‚Ä¢ Prefer computed properties over functions when no parameters needed.
      ‚Ä¢ Use `@MainActor` for UI-related classes and methods.
    links:
      - https://realm.github.io/SwiftLint/
    appliesTo:
      - "*.swift"

  - id: swiftui-best-practices
    description: |
      ‚Ä¢ Use @State for local view state, @StateObject for owned ViewModels.
      ‚Ä¢ Prefer @ObservedObject for injected ViewModels.
      ‚Ä¢ Use @Environment for shared app-wide dependencies.
      ‚Ä¢ Extract complex views into separate components when body exceeds 10-15 lines.
      ‚Ä¢ Use ViewBuilder for conditional view logic.
      ‚Ä¢ Prefer .task{} over .onAppear{} for async operations.
    appliesTo:
      - "Views/*.swift"

  - id: async-await-patterns
    description: |
      ‚Ä¢ Prefer async/await over Combine for new code.
      ‚Ä¢ Use @MainActor for UI updates from background tasks.
      ‚Ä¢ Handle cancellation with Task.isCancelled checks in long operations.
      ‚Ä¢ Use TaskGroup for concurrent operations.
    appliesTo:
      - "*.swift"

  - id: error-handling
    description: |
      ‚Ä¢ Create custom error types conforming to LocalizedError.
      ‚Ä¢ Use Result<Success, Failure> for operations that can fail.
      ‚Ä¢ Provide user-friendly error messages.
      ‚Ä¢ Log errors appropriately (avoid logging sensitive data).
    appliesTo:
      - "*.swift"

  - id: documentation
    description: |
      ‚Ä¢ Use triple-slash `///` comments for public types and methods.
      ‚Ä¢ Document parameters and return values.
      ‚Ä¢ Include code examples when behavior isn't obvious.
      ‚Ä¢ Use `// MARK: -` to organize code sections.
    links:
      - https://developer.apple.com/documentation/swift/documenting_your_code
    appliesTo:
      - "*.swift"

  - id: minimalist-ui & design
    description: |
      ‚Ä¢ Embrace whitespace: 16‚Äì24pt padding around elements.
      ‚Ä¢ Use system fonts (San Francisco) and semantic colors.
      ‚Ä¢ Default to neutral palette (white, gray), use accent sparingly.
      ‚Ä¢ Rely on SwiftUI's built-in components; minimize custom subviews.
      ‚Ä¢ Use SF Symbols for icons, sized appropriately (.font(.title2), etc.).
      ‚Ä¢ Implement dark mode support using semantic colors.
      ‚Ä¢ At the end the design should be something an iphone lover would appreciate with the clean esthetic 
    links:
      - https://developer.apple.com/design/human-interface-guidelines/ios/overview/themes/

  - id: logging-guidelines
    description: |
      ‚Ä¢ Use print() or os.log for development debugging.
      ‚Ä¢ Log method entry/exit for ViewModels and Services: "üîÑ [ClassName.methodName] Starting..."
      ‚Ä¢ Log success states: "‚úÖ [ClassName.methodName] Success: description"
      ‚Ä¢ Log error states: "‚ùå [ClassName.methodName] Error: \(error.localizedDescription)"
      ‚Ä¢ Log data flow: "üìä [ClassName] State changed to: \(newState)"
      ‚Ä¢ Avoid logging sensitive health data - use generic descriptions instead.
      ‚Ä¢ Use consistent prefixes: üîÑ (process), ‚úÖ (success), ‚ùå (error), üìä (data), üèÉ‚Äç‚ôÇÔ∏è (fitness-specific)
    appliesTo:
      - "*.swift"

  - id: dependency-injection
    description: |
      ‚Ä¢ Inject services into ViewModels via initializers for testability.
      ‚Ä¢ Avoid global singletons; pass environment objects explicitly.
      ‚Ä¢ Use protocols for all injected dependencies.
      ‚Ä¢ Provide mock implementations for testing.
    appliesTo:
      - "ViewModels/*.swift"

  - id: healthkit-service
    description: |
      ‚Ä¢ Wrap HKHealthStore in a protocol (HealthStoreProtocol) and a concrete HealthKitManager.
      ‚Ä¢ Service methods must return async/await or Combine publishers.
      ‚Ä¢ Handle HealthKit authorization states properly.
      ‚Ä¢ Request minimal necessary permissions.
      ‚Ä¢ Cache frequently accessed data appropriately.
    appliesTo:
      - "Services/HealthKitManager.swift"

  - id: model-protocols
    description: |
      ‚Ä¢ All models must conform to Identified protocol for UUID id and Identifiable/Hashable.
      ‚Ä¢ Use Timestamped protocol for models requiring creation tracking.
      ‚Ä¢ Leverage entityName computed property from Identified extension.
      ‚Ä¢ Example: struct User: Identified, Timestamped { var id = UUID(); var createdAt = Date() }
    appliesTo:
      - "Models/*.swift"
    description: |
      ‚Ä¢ Encapsulate SwiftData operations in PersistenceController.
      ‚Ä¢ Use @Model for SwiftData entities.
      ‚Ä¢ Provide preview sample data for SwiftUI Previews.
      ‚Ä¢ Handle migration scenarios gracefully.
      ‚Ä¢ Use background contexts for heavy data operations.
    appliesTo:
      - "Services/PersistenceController.swift"

  - id: testing-guidelines
    description: |
      ‚Ä¢ Write unit tests for ViewModels and Services.
      ‚Ä¢ Use dependency injection for testable code.
      ‚Ä¢ Mock external dependencies (HealthKit, network calls).
      ‚Ä¢ Test both success and failure scenarios.
      ‚Ä¢ Use XCTest and SwiftUI test utilities.
    appliesTo:
      - "Tests/*.swift"

  - id: performance
    description: |
      ‚Ä¢ Use @State and @StateObject judiciously to avoid unnecessary re-renders.
      ‚Ä¢ Implement lazy loading for large datasets.
      ‚Ä¢ Cache expensive computations when appropriate.
      ‚Ä¢ Profile memory usage with Instruments.
    appliesTo:
      - "*.swift"

# Templates for new files
templates:
  - id: viewmodel-template
    description: "Basic ViewModel with @Published properties and initializer."
    content: |-
      import Foundation
      import Combine

      @MainActor
      class {{Name}}ViewModel: ObservableObject {
          @Published var state: ViewState<{{Name}}Data> = .idle
          
          private let service: {{Name}}ServiceProtocol
          private var cancellables = Set<AnyCancellable>()

          init(service: {{Name}}ServiceProtocol) {
              self.service = service
              print("üîÑ [{{Name}}ViewModel.init] Initialized with service")
          }

          func loadData() async {
              print("üîÑ [{{Name}}ViewModel.loadData] Starting data load")
              state = .loading
              do {
                  let data = try await service.fetch{{Name}}Data()
                  print("‚úÖ [{{Name}}ViewModel.loadData] Successfully loaded data")
                  print("üìä [{{Name}}ViewModel] State changed to: loaded")
                  state = .loaded(data)
              } catch {
                  print("‚ùå [{{Name}}ViewModel.loadData] Error: \(error.localizedDescription)")
                  print("üìä [{{Name}}ViewModel] State changed to: error")
                  state = .error(error)
              }
          }
      }

      // MARK: - Supporting Types
      enum ViewState<T> {
          case idle
          case loading
          case loaded(T)
          case error(Error)
      }

  - id: view-template
    description: "SwiftUI View with proper ViewModel injection and state handling."
    content: |-
      import SwiftUI

      struct {{Name}}View: View {
          @StateObject private var viewModel: {{Name}}ViewModel
          
          init(service: {{Name}}ServiceProtocol) {
              print("üîÑ [{{Name}}View.init] Initializing view with service")
              self._viewModel = StateObject(wrappedValue: {{Name}}ViewModel(service: service))
          }

          var body: some View {
              NavigationView {
                  contentView
                      .navigationTitle("{{Name}}")
                      .task {
                          print("üîÑ [{{Name}}View] Task started - loading data")
                          await viewModel.loadData()
                      }
              }
          }
          
          @ViewBuilder
          private var contentView: some View {
              switch viewModel.state {
              case .idle, .loading:
                  ProgressView("Loading...")
                      .frame(maxWidth: .infinity, maxHeight: .infinity)
                  
              case .loaded(let data):
                  loadedView(data: data)
                  
              case .error(let error):
                  ErrorView(error: error) {
                      print("üîÑ [{{Name}}View] Retry button tapped")
                      Task {
                          await viewModel.loadData()
                      }
                  }
              }
          }
          
          private func loadedView(data: {{Name}}Data) -> some View {
              VStack(spacing: 16) {
                  Text("Data loaded successfully")
                  // Add your content here
              }
              .padding()
          }
      }

      // MARK: - Supporting Views
      struct ErrorView: View {
          let error: Error
          let retry: () -> Void
          
          var body: some View {
              VStack(spacing: 16) {
                  Image(systemName: "exclamationmark.triangle")
                      .font(.largeTitle)
                      .foregroundColor(.orange)
                  
                  Text("Something went wrong")
                      .font(.headline)
                  
                  Text(error.localizedDescription)
                      .font(.body)
                      .multilineTextAlignment(.center)
                      .foregroundColor(.secondary)
                  
                  Button("Try Again", action: retry)
                      .buttonStyle(.borderedProminent)
              }
              .padding()
          }
      }

  - id: service-protocol-template
    description: "Service protocol with async methods."
    content: |-
      import Foundation

      protocol {{Name}}ServiceProtocol {
          func fetch{{Name}}Data() async throws -> {{Name}}Data
          func save{{Name}}Data(_ data: {{Name}}Data) async throws
          func delete{{Name}}Data(id: UUID) async throws
      }

      // MARK: - Mock Implementation
      class Mock{{Name}}Service: {{Name}}ServiceProtocol {
          var shouldThrowError = false
          var mockData: {{Name}}Data?
          
          func fetch{{Name}}Data() async throws -> {{Name}}Data {
              print("üîÑ [Mock{{Name}}Service.fetch{{Name}}Data] Starting fetch")
              if shouldThrowError {
                  print("‚ùå [Mock{{Name}}Service.fetch{{Name}}Data] Throwing mock error")
                  throw {{Name}}Error.fetchFailed
              }
              print("‚úÖ [Mock{{Name}}Service.fetch{{Name}}Data] Returning mock data")
              return mockData ?? {{Name}}Data.preview
          }
          
          func save{{Name}}Data(_ data: {{Name}}Data) async throws {
              print("üîÑ [Mock{{Name}}Service.save{{Name}}Data] Starting save")
              if shouldThrowError {
                  print("‚ùå [Mock{{Name}}Service.save{{Name}}Data] Throwing mock error")
                  throw {{Name}}Error.saveFailed
              }
              print("‚úÖ [Mock{{Name}}Service.save{{Name}}Data] Save completed")
          }
          
          func delete{{Name}}Data(id: UUID) async throws {
              print("üîÑ [Mock{{Name}}Service.delete{{Name}}Data] Starting delete for id: \(id)")
              if shouldThrowError {
                  print("‚ùå [Mock{{Name}}Service.delete{{Name}}Data] Throwing mock error")
                  throw {{Name}}Error.deleteFailed
              }
              print("‚úÖ [Mock{{Name}}Service.delete{{Name}}Data] Delete completed")
          }
      }

  - id: model-template
    description: "SwiftData model with proper attributes."
    content: |-
      import Foundation
      import SwiftData

      @Model
      class {{Name}}: Identified, Timestamped {
          var id: UUID
          var createdAt: Date
          var updatedAt: Date
          
          // Add your properties here
          
          init() {
              self.id = UUID()
              self.createdAt = Date()
              self.updatedAt = Date()
              print("üîÑ [{{Name}}.init] Created new instance with id: \(id)")
          }
      }

      // MARK: - Preview Data
      extension {{Name}} {
          static var preview: {{Name}} {
              print("üîÑ [{{Name}}.preview] Creating preview instance")
              let item = {{Name}}()
              // Configure preview data
              return item
          }
      }

      // MARK: - Protocol Definitions
      /// Gives every model a UUID `id` + native Identifiable/Hashable conformance.
      protocol Identified: Identifiable, Hashable {
        var id: UUID { get set }
      }

      /// Gives any model a creation timestamp.
      protocol Timestamped {
        var createdAt: Date { get set }
      }

      /// Convenience to avoid hard-coding your entity names.
      extension Identified {
        static var entityName: String {
          String(describing: Self.self)
        }
      }

# ‚úÖ Auto-Completion Enabled Metadata
metadata:
  task-tracking:
    enabled: true
    system: markdown-checkbox
    format: "- [ ] [Task ID] Task description"  # Agent can mark as - [x] when complete
    filenamePattern: "tasks-*.md"
    completionSignal: "[x]"  # Marked as complete
    toolingHooks:
      cursor: true
      chatgpt-copilot: true
      ci-aware: true
      inline-feedback: true

# Continuous Integration
ci:
  steps:
    - id: build-app
      description: |
        Build the app for device (iphoneos) without launching any simulator unless needed for debugging.
      # make sure we‚Äôre in the UzoFitness directory
      script: |
        xcodebuild \
          -project UzoFitness.xcodeproj \
          -scheme UzoFitness \
          -configuration Debug \
          -sdk iphoneos \
          CODE_SIGN_IDENTITY="" \
          CODE_SIGNING_REQUIRED=NO \
          BUILD_DIR=build \
          build

    - id: run-unit-tests
      description: |
        Execute all unit tests on the iOS simulator (iPhone 15, iOS 18.0) when you make major developments
      script: |
        xcodebuild \
          -project UzoFitness.xcodeproj \
          -scheme UzoFitness \
          -configuration Debug \
          -sdk iphonesimulator \
          -destination 'platform=iOS Simulator,name=iPhone 15,OS=18.0' \
          test